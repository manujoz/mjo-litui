import{s as d,R as m,a as v,n as A,o as g,t as p,r as w,Q as P}from"./lit-core.js";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */let f=null;const $={boundAttributeSuffix:d.M,marker:d.P,markerMatch:d.A,HTML_RESULT:d.C,getTemplateHtml:d.L,overrideDirectiveResolve:(e,r)=>class extends e{_$AS(o,i){return r(this,i)}},patchDirectiveResolve:(e,r)=>{if(e.prototype._$AS!==r){f??(f=e.prototype._$AS.name);for(let o=e.prototype;o!==Object.prototype;o=Object.getPrototypeOf(o))if(o.hasOwnProperty(f))return void(o[f]=r);throw Error("Internal error: It is possible that both dev mode and production mode Lit was mixed together during SSR. Please comment on the issue: https://github.com/lit/lit/issues/4527")}},setDirectiveClass(e,r){e._$litDirective$=r},getAttributePartCommittedValue:(e,r,o)=>{let i=m;return e.j=n=>i=n,e._$AI(r,e,o),i},connectedDisconnectable:e=>({...e,_$AU:!0}),resolveDirective:d.V,AttributePart:d.H,PropertyPart:d.B,BooleanAttributePart:d.N,EventPart:d.U,ElementPart:d.F,TemplateInstance:d.R,isIterable:d.D,ChildPart:d.I};/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{TemplateInstance:E,isIterable:x,resolveDirective:b,ChildPart:h,ElementPart:_}=$,I=(e,r,o={})=>{if(r._$litPart$!==void 0)throw Error("container already contains a live render");let i,n,a;const t=[],c=document.createTreeWalker(r,NodeFilter.SHOW_COMMENT);let s;for(;(s=c.nextNode())!==null;){const l=s.data;if(l.startsWith("lit-part")){if(t.length===0&&i!==void 0)throw Error(`There must be only one root part per container. Found a part marker (${s}) when we already have a root part marker (${n})`);a=T(e,s,t,o),i===void 0&&(i=a),n??(n=s)}else if(l.startsWith("lit-node"))C(s,t,o);else if(l.startsWith("/lit-part")){if(t.length===1&&a!==i)throw Error("internal error");a=R(s,a,t)}}if(i===void 0){const l=r instanceof ShadowRoot?"{container.host.localName}'s shadow root":r instanceof DocumentFragment?"DocumentFragment":r.localName;console.error(`There should be exactly one root part in a render container, but we didn't find any in ${l}.`)}r._$litPart$=i},T=(e,r,o,i)=>{let n,a;if(o.length===0)a=new h(r,null,void 0,i),n=e;else{const t=o[o.length-1];if(t.type==="template-instance")a=new h(r,null,t.instance,i),t.instance._$AV.push(a),n=t.result.values[t.instancePartIndex++],t.templatePartIndex++;else if(t.type==="iterable"){a=new h(r,null,t.part,i);const c=t.iterator.next();if(c.done)throw n=void 0,t.done=!0,Error("Unhandled shorter than expected iterable");n=c.value,t.part._$AH.push(a)}else a=new h(r,null,t.part,i)}if(n=b(a,n),n===m)o.push({part:a,type:"leaf"});else if(v(n))o.push({part:a,type:"leaf"}),a._$AH=n;else if(A(n)){if(g(n))throw Error("compiled templates are not supported");const t="lit-part "+O(n);if(r.data!==t)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const c=h.prototype._$AC(n),s=new E(c,a);o.push({type:"template-instance",instance:s,part:a,templatePartIndex:0,instancePartIndex:0,result:n}),a._$AH=s}}else x(n)?(o.push({part:a,type:"iterable",value:n,iterator:n[Symbol.iterator](),done:!1}),a._$AH=[]):(o.push({part:a,type:"leaf"}),a._$AH=n??"");return a},R=(e,r,o)=>{if(r===void 0)throw Error("unbalanced part marker");r._$AB=e;const i=o.pop();if(i.type==="iterable"&&!i.iterator.next().done)throw Error("unexpected longer than expected iterable");if(o.length>0)return o[o.length-1].part},C=(e,r,o)=>{const i=/lit-node (\d+)/.exec(e.data),n=parseInt(i[1]),a=e.nextElementSibling;if(a===null)throw Error("could not find node for attribute parts");a.removeAttribute("defer-hydration");const t=r[r.length-1];if(t.type!=="template-instance")throw Error("Hydration value mismatch: Primitive found where TemplateResult expected. This usually occurs due to conditional rendering that resulted in a different value or template being rendered between the server and client.");{const c=t.instance;for(;;){const s=c._$AD.parts[t.templatePartIndex];if(s===void 0||s.type!==p.ATTRIBUTE&&s.type!==p.ELEMENT||s.index!==n)break;if(s.type===p.ATTRIBUTE){const l=new s.ctor(a,s.name,s.strings,t.instance,o),u=w(l)?t.result.values[t.instancePartIndex]:t.result.values,y=!(l.type===p.EVENT||l.type===p.PROPERTY);l._$AI(u,l,t.instancePartIndex,y),t.instancePartIndex+=s.strings.length-1,c._$AV.push(l)}else{const l=new _(a,t.instance,o);b(l,t.result.values[t.instancePartIndex++]),c._$AV.push(l)}t.templatePartIndex++}}},O=e=>{const r=new Uint32Array(2).fill(5381);for(const i of e.strings)for(let n=0;n<i.length;n++)r[n%2]=33*r[n%2]^i.charCodeAt(n);const o=String.fromCharCode(...new Uint8Array(r.buffer));return btoa(o)};globalThis.litElementHydrateSupport=({LitElement:e})=>{const r=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e),"observedAttributes").get;Object.defineProperty(e,"observedAttributes",{get(){return[...r.call(this),"defer-hydration"]}});const o=e.prototype.attributeChangedCallback;e.prototype.attributeChangedCallback=function(t,c,s){t==="defer-hydration"&&s===null&&i.call(this),o.call(this,t,c,s)};const i=e.prototype.connectedCallback;e.prototype.connectedCallback=function(){this.hasAttribute("defer-hydration")||i.call(this)};const n=e.prototype.createRenderRoot;e.prototype.createRenderRoot=function(){return this.shadowRoot?(this._$AG=!0,this.shadowRoot):n.call(this)};const a=Object.getPrototypeOf(e.prototype).update;e.prototype.update=function(t){const c=this.render();if(a.call(this,t),this._$AG){this._$AG=!1;for(let s=0;s<this.attributes.length;s++){const l=this.attributes[s];if(l.name.startsWith("hydrate-internals-")){const u=l.name.slice(18);this.removeAttribute(u),this.removeAttribute(l.name)}}I(c,this.renderRoot,this.renderOptions)}else P(c,this.renderRoot,this.renderOptions)}};
//# sourceMappingURL=lit-hydration.js.map
