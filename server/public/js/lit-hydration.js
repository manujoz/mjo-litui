import{s as d,R as m,t as p,Q as v}from"./lit-core.js";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */let f=null;const A={boundAttributeSuffix:d.M,marker:d.P,markerMatch:d.A,HTML_RESULT:d.C,getTemplateHtml:d.L,overrideDirectiveResolve:(t,e)=>class extends t{_$AS(o,a){return e(this,a)}},patchDirectiveResolve:(t,e)=>{if(t.prototype._$AS!==e){f??(f=t.prototype._$AS.name);for(let o=t.prototype;o!==Object.prototype;o=Object.getPrototypeOf(o))if(o.hasOwnProperty(f))return void(o[f]=e);throw Error("Internal error: It is possible that both dev mode and production mode Lit was mixed together during SSR. Please comment on the issue: https://github.com/lit/lit/issues/4527")}},setDirectiveClass(t,e){t._$litDirective$=e},getAttributePartCommittedValue:(t,e,o)=>{let a=m;return t.j=n=>a=n,t._$AI(e,t,o),a},connectedDisconnectable:t=>({...t,_$AU:!0}),resolveDirective:d.V,AttributePart:d.H,PropertyPart:d.B,BooleanAttributePart:d.N,EventPart:d.U,ElementPart:d.F,TemplateInstance:d.R,isIterable:d.D,ChildPart:d.I};/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const g=t=>t===null||typeof t!="object"&&typeof t!="function",$=(t,e)=>e===void 0?(t==null?void 0:t._$litType$)!==void 0:(t==null?void 0:t._$litType$)===e,w=t=>{var e;return((e=t==null?void 0:t._$litType$)==null?void 0:e.h)!=null},P=t=>t.strings===void 0;/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{TemplateInstance:_,isIterable:E,resolveDirective:y,ChildPart:h,ElementPart:x}=A,T=(t,e,o={})=>{if(e._$litPart$!==void 0)throw Error("container already contains a live render");let a,n,i;const r=[],c=document.createTreeWalker(e,NodeFilter.SHOW_COMMENT);let l;for(;(l=c.nextNode())!==null;){const s=l.data;if(s.startsWith("lit-part")){if(r.length===0&&a!==void 0)throw Error(`There must be only one root part per container. Found a part marker (${l}) when we already have a root part marker (${n})`);i=I(t,l,r,o),a===void 0&&(a=i),n??(n=l)}else if(s.startsWith("lit-node"))C(l,r,o);else if(s.startsWith("/lit-part")){if(r.length===1&&i!==a)throw Error("internal error");i=R(l,i,r)}}if(a===void 0){const s=e instanceof ShadowRoot?"{container.host.localName}'s shadow root":e instanceof DocumentFragment?"DocumentFragment":e.localName;console.error(`There should be exactly one root part in a render container, but we didn't find any in ${s}.`)}e._$litPart$=a},I=(t,e,o,a)=>{let n,i;if(o.length===0)i=new h(e,null,void 0,a),n=t;else{const r=o[o.length-1];if(r.type==="template-instance")i=new h(e,null,r.instance,a),r.instance._$AV.push(i),n=r.result.values[r.instancePartIndex++],r.templatePartIndex++;else if(r.type==="iterable"){i=new h(e,null,r.part,a);const c=r.iterator.next();if(c.done)throw n=void 0,r.done=!0,Error("Unhandled shorter than expected iterable");n=c.value,r.part._$AH.push(i)}else i=new h(e,null,r.part,a)}if(n=y(i,n),n===m)o.push({part:i,type:"leaf"});else if(g(n))o.push({part:i,type:"leaf"}),i._$AH=n;else if($(n)){if(w(n))throw Error("compiled templates are not supported");const r="lit-part "+O(n);if(e.data!==r)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const c=h.prototype._$AC(n),l=new _(c,i);o.push({type:"template-instance",instance:l,part:i,templatePartIndex:0,instancePartIndex:0,result:n}),i._$AH=l}}else E(n)?(o.push({part:i,type:"iterable",value:n,iterator:n[Symbol.iterator](),done:!1}),i._$AH=[]):(o.push({part:i,type:"leaf"}),i._$AH=n??"");return i},R=(t,e,o)=>{if(e===void 0)throw Error("unbalanced part marker");e._$AB=t;const a=o.pop();if(a.type==="iterable"&&!a.iterator.next().done)throw Error("unexpected longer than expected iterable");if(o.length>0)return o[o.length-1].part},C=(t,e,o)=>{const a=/lit-node (\d+)/.exec(t.data),n=parseInt(a[1]),i=t.nextElementSibling;if(i===null)throw Error("could not find node for attribute parts");i.removeAttribute("defer-hydration");const r=e[e.length-1];if(r.type!=="template-instance")throw Error("Hydration value mismatch: Primitive found where TemplateResult expected. This usually occurs due to conditional rendering that resulted in a different value or template being rendered between the server and client.");{const c=r.instance;for(;;){const l=c._$AD.parts[r.templatePartIndex];if(l===void 0||l.type!==p.ATTRIBUTE&&l.type!==p.ELEMENT||l.index!==n)break;if(l.type===p.ATTRIBUTE){const s=new l.ctor(i,l.name,l.strings,r.instance,o),u=P(s)?r.result.values[r.instancePartIndex]:r.result.values,b=!(s.type===p.EVENT||s.type===p.PROPERTY);s._$AI(u,s,r.instancePartIndex,b),r.instancePartIndex+=l.strings.length-1,c._$AV.push(s)}else{const s=new x(i,r.instance,o);y(s,r.result.values[r.instancePartIndex++]),c._$AV.push(s)}r.templatePartIndex++}}},O=t=>{const e=new Uint32Array(2).fill(5381);for(const a of t.strings)for(let n=0;n<a.length;n++)e[n%2]=33*e[n%2]^a.charCodeAt(n);const o=String.fromCharCode(...new Uint8Array(e.buffer));return btoa(o)};globalThis.litElementHydrateSupport=({LitElement:t})=>{const e=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t),"observedAttributes").get;Object.defineProperty(t,"observedAttributes",{get(){return[...e.call(this),"defer-hydration"]}});const o=t.prototype.attributeChangedCallback;t.prototype.attributeChangedCallback=function(r,c,l){r==="defer-hydration"&&l===null&&a.call(this),o.call(this,r,c,l)};const a=t.prototype.connectedCallback;t.prototype.connectedCallback=function(){this.hasAttribute("defer-hydration")||a.call(this)};const n=t.prototype.createRenderRoot;t.prototype.createRenderRoot=function(){return this.shadowRoot?(this._$AG=!0,this.shadowRoot):n.call(this)};const i=Object.getPrototypeOf(t.prototype).update;t.prototype.update=function(r){const c=this.render();if(i.call(this,r),this._$AG){this._$AG=!1;for(let l=0;l<this.attributes.length;l++){const s=this.attributes[l];if(s.name.startsWith("hydrate-internals-")){const u=s.name.slice(18);this.removeAttribute(u),this.removeAttribute(s.name)}}T(c,this.renderRoot,this.renderOptions)}else v(c,this.renderRoot,this.renderOptions)}};
//# sourceMappingURL=lit-hydration.js.map
