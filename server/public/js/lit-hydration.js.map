{"version":3,"file":"lit-hydration.js","sources":["../../../node_modules/lit-html/development/private-ssr-support.js","../../../node_modules/@lit-labs/ssr-client/development/lib/hydrate-lit-html.js","../../../node_modules/@lit-labs/ssr-client/development/lit-element-hydrate-support.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { _$LH as p, noChange, } from './lit-html.js';\n// Contains either the minified or unminified `_$resolve` Directive method name.\nlet resolveMethodName = null;\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports mangled in the\n * client side code, we export a _$LH object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n * @private\n */\nexport const _$LH = {\n    boundAttributeSuffix: p._boundAttributeSuffix,\n    marker: p._marker,\n    markerMatch: p._markerMatch,\n    HTML_RESULT: p._HTML_RESULT,\n    getTemplateHtml: p._getTemplateHtml,\n    overrideDirectiveResolve: (directiveClass, resolveOverrideFn) => class extends directiveClass {\n        _$resolve(_part, values) {\n            return resolveOverrideFn(this, values);\n        }\n    },\n    patchDirectiveResolve: (directiveClass, resolveOverrideFn) => {\n        if (directiveClass.prototype._$resolve !== resolveOverrideFn) {\n            resolveMethodName ??= directiveClass.prototype._$resolve\n                .name;\n            for (let proto = directiveClass.prototype; proto !== Object.prototype; proto = Object.getPrototypeOf(proto)) {\n                if (proto.hasOwnProperty(resolveMethodName)) {\n                    proto[resolveMethodName] = resolveOverrideFn;\n                    return;\n                }\n            }\n            // Nothing was patched which indicates an error. The most likely error is\n            // that somehow both minified and unminified lit code passed through this\n            // codepath. This is possible as lit-labs/ssr contains its own lit-html\n            // module as a dependency for server rendering client Lit code. If a\n            // client contains multiple duplicate Lit modules with minified and\n            // unminified exports, we currently cannot handle both.\n            throw new Error(`Internal error: It is possible that both dev mode and production mode` +\n                ` Lit was mixed together during SSR. Please comment on the issue: ` +\n                `https://github.com/lit/lit/issues/4527`);\n        }\n    },\n    setDirectiveClass(value, directiveClass) {\n        // This property needs to remain unminified.\n        value['_$litDirective$'] = directiveClass;\n    },\n    getAttributePartCommittedValue: (part, value, index) => {\n        // Use the part setter to resolve directives/concatenate multiple parts\n        // into a final value (captured by passing in a commitValue override)\n        let committedValue = noChange;\n        // Note that _commitValue need not be in `stableProperties` because this\n        // method is only run on `AttributePart`s created by lit-ssr using the same\n        // version of the library as this file\n        part._commitValue = (value) => (committedValue = value);\n        part._$setValue(value, part, index);\n        return committedValue;\n    },\n    connectedDisconnectable: (props) => ({\n        ...props,\n        _$isConnected: true,\n    }),\n    resolveDirective: p._resolveDirective,\n    AttributePart: p._AttributePart,\n    PropertyPart: p._PropertyPart,\n    BooleanAttributePart: p._BooleanAttributePart,\n    EventPart: p._EventPart,\n    ElementPart: p._ElementPart,\n    TemplateInstance: p._TemplateInstance,\n    isIterable: p._isIterable,\n    ChildPart: p._ChildPart,\n};\n//# sourceMappingURL=private-ssr-support.js.map","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange, } from 'lit-html';\nimport { _$LH } from 'lit-html/private-ssr-support.js';\nimport { PartType, } from 'lit-html/directive.js';\nimport { isPrimitive, isSingleExpression, isTemplateResult, isCompiledTemplateResult, } from 'lit-html/directive-helpers.js';\n// In the Node build, this import will be injected by Rollup:\n// import {Buffer} from 'buffer';\nconst NODE_MODE = false;\nconst { TemplateInstance, isIterable, resolveDirective, ChildPart, ElementPart } = _$LH;\n/**\n * hydrate() operates on a container with server-side rendered content and\n * restores the client side data structures needed for lit-html updates such as\n * TemplateInstances and Parts. After calling `hydrate`, lit-html will behave as\n * if it initially rendered the DOM, and any subsequent updates will update\n * efficiently, the same as if lit-html had rendered the DOM on the client.\n *\n * hydrate() must be called on DOM that adheres the to lit-ssr structure for\n * parts. ChildParts must be represented with both a start and end comment\n * marker, and ChildParts that contain a TemplateInstance must have the template\n * digest written into the comment data.\n *\n * Since render() encloses its output in a ChildPart, there must always be a root\n * ChildPart.\n *\n * Example (using for # ... for annotations in HTML)\n *\n * Given this input:\n *\n *   html`<div class=${x}>${y}</div>`\n *\n * The SSR DOM is:\n *\n *   <!--lit-part AEmR7W+R0Ak=-->  # Start marker for the root ChildPart created\n *                                 # by render(). Includes the digest of the\n *                                 # template\n *   <!--lit-node 0--> # Indicates there are attribute bindings in next node\n *                     # The number is the depth-first index of the parent\n *                     # node in the template.\n *   <div class=\"TEST_X\">\n *     <!--lit-part-->  # Start marker for the ${y} expression\n *     TEST_Y\n *     <!--/lit-part-->  # End marker for the ${y} expression\n *   </div>\n *\n *   <!--/lit-part-->  # End marker for the root ChildPart\n *\n * @param rootValue\n * @param container\n * @param userOptions\n */\nexport const hydrate = (rootValue, container, options = {}) => {\n    // TODO(kschaaf): Do we need a helper for _$litPart$ (\"part for node\")?\n    // This property needs to remain unminified.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (container['_$litPart$'] !== undefined) {\n        throw new Error('container already contains a live render');\n    }\n    // Since render() creates a ChildPart to render into, we'll always have\n    // exactly one root part. We need to hold a reference to it so we can set\n    // it in the parts cache.\n    let rootPart = undefined;\n    // Used for error messages\n    let rootPartMarker = undefined;\n    // When we are in-between ChildPart markers, this is the current ChildPart.\n    // It's needed to be able to set the ChildPart's endNode when we see a\n    // close marker\n    let currentChildPart = undefined;\n    // Used to remember parent template state as we recurse into nested\n    // templates\n    const stack = [];\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_COMMENT);\n    let marker;\n    // Walk the DOM looking for part marker comments\n    while ((marker = walker.nextNode()) !== null) {\n        const markerText = marker.data;\n        if (markerText.startsWith('lit-part')) {\n            if (stack.length === 0 && rootPart !== undefined) {\n                throw new Error(`There must be only one root part per container. ` +\n                    `Found a part marker (${marker}) when we already have a root ` +\n                    `part marker (${rootPartMarker})`);\n            }\n            // Create a new ChildPart and push it onto the stack\n            currentChildPart = openChildPart(rootValue, marker, stack, options);\n            // Using nullish logical assignment below can cause next.js's swc to move\n            // the `openChildPart()` call above behind the nullish check.\n            // See https://github.com/lit/lit/issues/4289\n            if (rootPart === undefined) {\n                rootPart = currentChildPart;\n            }\n            rootPartMarker ??= marker;\n        }\n        else if (markerText.startsWith('lit-node')) {\n            // Create and hydrate attribute parts into the current ChildPart on the\n            // stack\n            createAttributeParts(marker, stack, options);\n        }\n        else if (markerText.startsWith('/lit-part')) {\n            // Close the current ChildPart, and pop the previous one off the stack\n            if (stack.length === 1 && currentChildPart !== rootPart) {\n                throw new Error('internal error');\n            }\n            currentChildPart = closeChildPart(marker, currentChildPart, stack);\n        }\n    }\n    if (rootPart === undefined) {\n        const elementMessage = container instanceof ShadowRoot\n            ? `{container.host.localName}'s shadow root`\n            : container instanceof DocumentFragment\n                ? 'DocumentFragment'\n                : container.localName;\n        console.error(`There should be exactly one root part in a render container, ` +\n            `but we didn't find any in ${elementMessage}.`);\n    } // This property needs to remain unminified.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    container['_$litPart$'] = rootPart;\n};\nconst openChildPart = (rootValue, marker, stack, options) => {\n    let value;\n    // We know the startNode now. We'll know the endNode when we get to\n    // the matching marker and set it in closeChildPart()\n    // TODO(kschaaf): Current constructor takes both nodes\n    let part;\n    if (stack.length === 0) {\n        part = new ChildPart(marker, null, undefined, options);\n        value = rootValue;\n    }\n    else {\n        const state = stack[stack.length - 1];\n        if (state.type === 'template-instance') {\n            part = new ChildPart(marker, null, state.instance, options);\n            state.instance._$parts.push(part);\n            value = state.result.values[state.instancePartIndex++];\n            state.templatePartIndex++;\n        }\n        else if (state.type === 'iterable') {\n            part = new ChildPart(marker, null, state.part, options);\n            const result = state.iterator.next();\n            if (result.done) {\n                value = undefined;\n                state.done = true;\n                throw new Error('Unhandled shorter than expected iterable');\n            }\n            else {\n                value = result.value;\n            }\n            state.part._$committedValue.push(part);\n        }\n        else {\n            // state.type === 'leaf'\n            // TODO(kschaaf): This is unexpected, and likely a result of a primitive\n            // been rendered on the client when a TemplateResult was rendered on the\n            // server; this part will be hydrated but not used. We can detect it, but\n            // we need to decide what to do in this case. Note that this part won't be\n            // retained by any parent TemplateInstance, since a primitive had been\n            // rendered in its place.\n            // https://github.com/lit/lit/issues/1434\n            // throw new Error('Hydration value mismatch: Found a TemplateInstance' +\n            //  'where a leaf value was expected');\n            part = new ChildPart(marker, null, state.part, options);\n        }\n    }\n    // Initialize the ChildPart state depending on the type of value and push\n    // it onto the stack. This logic closely follows the ChildPart commit()\n    // cascade order:\n    // 1. directive\n    // 2. noChange\n    // 3. primitive (note strings must be handled before iterables, since they\n    //    are iterable)\n    // 4. TemplateResult\n    // 5. Node (not yet implemented, but fallback handling is fine)\n    // 6. Iterable\n    // 7. nothing (handled in fallback)\n    // 8. Fallback for everything else\n    value = resolveDirective(part, value);\n    if (value === noChange) {\n        stack.push({ part, type: 'leaf' });\n    }\n    else if (isPrimitive(value)) {\n        stack.push({ part, type: 'leaf' });\n        part._$committedValue = value;\n        // TODO(kschaaf): We can detect when a primitive is being hydrated on the\n        // client where a TemplateResult was rendered on the server, but we need to\n        // decide on a strategy for what to do next.\n        // https://github.com/lit/lit/issues/1434\n        // if (marker.data !== 'lit-part') {\n        //   throw new Error('Hydration value mismatch: Primitive found where TemplateResult expected');\n        // }\n    }\n    else if (isTemplateResult(value)) {\n        if (isCompiledTemplateResult(value)) {\n            throw new Error('compiled templates are not supported');\n        }\n        // Check for a template result digest\n        const markerWithDigest = `lit-part ${digestForTemplateResult(value)}`;\n        if (marker.data === markerWithDigest) {\n            const template = ChildPart.prototype._$getTemplate(value);\n            const instance = new TemplateInstance(template, part);\n            stack.push({\n                type: 'template-instance',\n                instance,\n                part,\n                templatePartIndex: 0,\n                instancePartIndex: 0,\n                result: value,\n            });\n            // For TemplateResult values, we set the part value to the\n            // generated TemplateInstance\n            part._$committedValue = instance;\n        }\n        else {\n            // TODO: if this isn't the server-rendered template, do we\n            // need to stop hydrating this subtree? Clear it? Add tests.\n            throw new Error('Hydration value mismatch: Unexpected TemplateResult rendered to part');\n        }\n    }\n    else if (isIterable(value)) {\n        // currentChildPart.value will contain an array of ChildParts\n        stack.push({\n            part: part,\n            type: 'iterable',\n            value,\n            iterator: value[Symbol.iterator](),\n            done: false,\n        });\n        part._$committedValue = [];\n    }\n    else {\n        // Fallback for everything else (nothing, Objects, Functions,\n        // etc.): we just initialize the part's value\n        // Note that `Node` value types are not currently supported during\n        // SSR, so that part of the cascade is missing.\n        stack.push({ part: part, type: 'leaf' });\n        part._$committedValue = value == null ? '' : value;\n    }\n    return part;\n};\nconst closeChildPart = (marker, part, stack) => {\n    if (part === undefined) {\n        throw new Error('unbalanced part marker');\n    }\n    part._$endNode = marker;\n    const currentState = stack.pop();\n    if (currentState.type === 'iterable') {\n        if (!currentState.iterator.next().done) {\n            throw new Error('unexpected longer than expected iterable');\n        }\n    }\n    if (stack.length > 0) {\n        const state = stack[stack.length - 1];\n        return state.part;\n    }\n    else {\n        return undefined;\n    }\n};\nconst createAttributeParts = (comment, stack, options) => {\n    // Get the nodeIndex from DOM. We're only using this for an integrity\n    // check right now, we might not need it.\n    const match = /lit-node (\\d+)/.exec(comment.data);\n    const nodeIndex = parseInt(match[1]);\n    // Node markers are added as a previous sibling to identify elements\n    // with attribute/property/element/event bindings or custom elements\n    // whose `defer-hydration` attribute needs to be removed\n    const node = comment.nextElementSibling;\n    if (node === null) {\n        throw new Error('could not find node for attribute parts');\n    }\n    // Remove `defer-hydration` attribute, if any\n    node.removeAttribute('defer-hydration');\n    const state = stack[stack.length - 1];\n    if (state.type === 'template-instance') {\n        const instance = state.instance;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // If the next template part is in attribute-position on the current node,\n            // create the instance part for it and prime its state\n            const templatePart = instance._$template.parts[state.templatePartIndex];\n            if (templatePart === undefined ||\n                (templatePart.type !== PartType.ATTRIBUTE &&\n                    templatePart.type !== PartType.ELEMENT) ||\n                templatePart.index !== nodeIndex) {\n                break;\n            }\n            if (templatePart.type === PartType.ATTRIBUTE) {\n                // The instance part is created based on the constructor saved in the\n                // template part\n                const instancePart = new templatePart.ctor(node, templatePart.name, templatePart.strings, state.instance, options);\n                const value = isSingleExpression(instancePart)\n                    ? state.result.values[state.instancePartIndex]\n                    : state.result.values;\n                // Setting the attribute value primes committed value with the resolved\n                // directive value; we only then commit that value for event/property\n                // parts since those were not serialized, and pass `noCommit` for the\n                // others to avoid perf impact of touching the DOM unnecessarily\n                const noCommit = !(instancePart.type === PartType.EVENT ||\n                    instancePart.type === PartType.PROPERTY);\n                instancePart._$setValue(value, instancePart, state.instancePartIndex, noCommit);\n                state.instancePartIndex += templatePart.strings.length - 1;\n                instance._$parts.push(instancePart);\n            }\n            else {\n                // templatePart.type === PartType.ELEMENT\n                const instancePart = new ElementPart(node, state.instance, options);\n                resolveDirective(instancePart, state.result.values[state.instancePartIndex++]);\n                instance._$parts.push(instancePart);\n            }\n            state.templatePartIndex++;\n        }\n    }\n    else {\n        // TODO(augustjk): This message may need to be updated based on\n        // hydration strategy. See https://github.com/lit/lit/issues/1434\n        throw new Error(`Hydration value mismatch: Primitive found where TemplateResult expected.` +\n            ` This usually occurs due to conditional rendering that resulted in a ` +\n            `different value or template being rendered between the server and client.`);\n    }\n};\n// Number of 32 bit elements to use to create template digests\nconst digestSize = 2;\n// We need to specify a digest to use across rendering environments. This is a\n// simple digest build from a DJB2-ish hash modified from:\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\n// It has been changed to an array of hashes to add additional bits.\n// Goals:\n//  - Extremely low collision rate. We may not be able to detect collisions.\n//  - Extremely fast.\n//  - Extremely small code size.\n//  - Safe to include in HTML comment text or attribute value.\n//  - Easily specifiable and implementable in multiple languages.\n// We don't care about cryptographic suitability.\nexport const digestForTemplateResult = (templateResult) => {\n    const hashes = new Uint32Array(digestSize).fill(5381);\n    for (const s of templateResult.strings) {\n        for (let i = 0; i < s.length; i++) {\n            hashes[i % digestSize] = (hashes[i % digestSize] * 33) ^ s.charCodeAt(i);\n        }\n    }\n    const str = String.fromCharCode(...new Uint8Array(hashes.buffer));\n    // Use `btoa` in browsers because it is supported universally.\n    //\n    // In Node, we are sometimes executing in an isolated VM context, which means\n    // neither `btoa` nor `Buffer` will be globally available by default (also\n    // note that `btoa` is only supported in Node 16+ anyway, and we still support\n    // Node 14). Instead of requiring users to always provide an implementation\n    // for `btoa` when they set up their VM context, we instead inject an import\n    // for `Buffer` from Node's built-in `buffer` module in our Rollup config (see\n    // note at the top of this file), and use that.\n    return NODE_MODE ? Buffer.from(str, 'binary').toString('base64') : btoa(str);\n};\n//# sourceMappingURL=hydrate-lit-html.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { render } from 'lit-html';\nimport { hydrate } from './lib/hydrate-lit-html.js';\n// Keep consistent with `@lit-labs/ssr-dom-shim`\nconst HYDRATE_INTERNALS_ATTR_PREFIX = 'hydrate-internals-';\nglobalThis.litElementHydrateSupport = ({ LitElement, }) => {\n    const observedAttributes = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(LitElement), 'observedAttributes').get;\n    // Add `defer-hydration` to observedAttributes\n    Object.defineProperty(LitElement, 'observedAttributes', {\n        get() {\n            return [...observedAttributes.call(this), 'defer-hydration'];\n        },\n    });\n    // Enable element when 'defer-hydration' attribute is removed by calling the\n    // super.connectedCallback()\n    const attributeChangedCallback = LitElement.prototype.attributeChangedCallback;\n    LitElement.prototype.attributeChangedCallback = function (name, old, value) {\n        if (name === 'defer-hydration' && value === null) {\n            connectedCallback.call(this);\n        }\n        attributeChangedCallback.call(this, name, old, value);\n    };\n    // Override `connectedCallback` to capture whether we need hydration, and\n    // defer `super.connectedCallback()` if the 'defer-hydration' attribute is set\n    const connectedCallback = LitElement.prototype.connectedCallback;\n    LitElement.prototype.connectedCallback = function () {\n        // If the outer scope of this element has not yet been hydrated, wait until\n        // 'defer-hydration' attribute has been removed to enable\n        if (!this.hasAttribute('defer-hydration')) {\n            connectedCallback.call(this);\n        }\n    };\n    // If we've been server-side rendered, just return `this.shadowRoot`, don't\n    // call the base implementation, which would also adopt styles (for now)\n    const createRenderRoot = LitElement.prototype.createRenderRoot;\n    LitElement.prototype.createRenderRoot = function () {\n        if (this.shadowRoot) {\n            this._$needsHydration = true;\n            return this.shadowRoot;\n        }\n        else {\n            return createRenderRoot.call(this);\n        }\n    };\n    // Hydrate on first update when needed\n    const update = Object.getPrototypeOf(LitElement.prototype).update;\n    LitElement.prototype.update = function (changedProperties) {\n        const value = this.render();\n        // Since this is a patch, we can't call super.update(), so we capture\n        // it off the proto chain and call it instead\n        update.call(this, changedProperties);\n        if (this._$needsHydration) {\n            this._$needsHydration = false;\n            // Remove aria attributes added by internals shim during SSR\n            for (let i = 0; i < this.attributes.length; i++) {\n                const attr = this.attributes[i];\n                if (attr.name.startsWith(HYDRATE_INTERNALS_ATTR_PREFIX)) {\n                    const ariaAttr = attr.name.slice(HYDRATE_INTERNALS_ATTR_PREFIX.length);\n                    this.removeAttribute(ariaAttr);\n                    this.removeAttribute(attr.name);\n                }\n            }\n            hydrate(value, this.renderRoot, this.renderOptions);\n        }\n        else {\n            render(value, this.renderRoot, this.renderOptions);\n        }\n    };\n};\n//# sourceMappingURL=lit-element-hydrate-support.js.map"],"names":["p","value"],"mappings":"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","x_google_ignoreList":[0,1,2]}